<!doctype html>
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Opening Jupyter on your laptop - Data science for everyone - 2019</title>
<meta name="description" content="">



<meta property="og:type" content="website">
<meta property="og:locale" content="en_UK">
<meta property="og:site_name" content="Data science for everyone - 2019">
<meta property="og:title" content="Data science for everyone - 2019">
<meta property="og:url" content="https://matthew-brett.github.io/dsfe2019/notebooks/07/pandas_indexing.Rmd">












  

  


<link rel="canonical" href="https://matthew-brett.github.io/dsfe2019/notebooks/07/pandas_indexing.Rmd">







  <script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "Person",
      "name": "Matthew Brett",
      "url": "https://matthew-brett.github.io/dsfe2019",
      "sameAs": null
    }
  </script>







<!-- end _includes/seo.html -->


<link href="/dsfe2019/feed.xml" type="application/atom+xml" rel="alternate" title="Data science for everyone - 2019 Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/dsfe2019/assets/css/main.css">

<!--[if lte IE 9]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->


<!-- end custom head snippets -->

    <link rel="stylesheet" href="/dsfe2019/assets/css/notebook-markdown.css">
    <link rel="stylesheet" href="/dsfe2019/assets/css/custom.css">
    <link rel="shortcut icon" type="image/png" href="/dsfe2019/favicon.png">
    <script src="https://cdn.jsdelivr.net/npm/clipboard@1/dist/clipboard.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.1/anchor.min.js"></script>
  </head>

  <body class="layout--single">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    
    <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="/dsfe2019/">
          <img src="/dsfe2019/images/dsfe_logo.png" class="masthead_logo" />
          Data science for everyone - 2019
        </a>
        <ul class="visible-links">
          
            
            <li class="masthead__menu-item">
              <a href="https://matthew-brett.github.io/dsfe2019/about" >About</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://matthew-brett.github.io/dsfe2019/syllabus" >Syllabus</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://matthew-brett.github.io/dsfe2019/classes" >Classes</a>
            </li>
          
          
            <li class="masthead__menu-item">
              <a href="/dsfe2019/chapters/01/intro">Textbook</a>
            </li>
          
          
        </ul>
        
        <button class="search__toggle" type="button">
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle Menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

    

    <div class="initial-content">
      



<div id="main" role="main">
  

  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          <!--  -->
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        Way back in the [introduction to data frames](/dsfe2019/chapters/03/data_frame_intro), we covered indexing into data frames with
*Boolean vectors*, such as Pandas Series or Numpy arrays, and indexing into data frames with column names.

This page covers more sophisticated indexing in Pandas.

To understand this indexing, we first need to cover the *index* of data frames
and Series.

We start with our usual imports:

```{python}
# Load the Numpy library, rename to "np"
import numpy as np

# Load the Pandas data science library, rename to "pd"
import pandas as pd
```

## The index

We start by going back to our first data frame, containing statistics on development and gender from the world bank.

This is the [gender_stats.csv](/dsfe2019/data/gender_stats.csv) file.  See [the gender stats data page](https://github.com/matthew-brett/datasets/tree/master/gender_stats) for some more detail.

Download that file to the same directory as this notebook, if you are running on your own computer.

```{python}
# Load the data file as a data frame.
gender_data = pd.read_csv('gender_stats.csv')

# Show the first 10 rows
gender_data.head(10)
```
As you know, the names at the top, in **bold typeface**, are the names of the columns.  We can see these names using the `columns` attribute of the data frame:

```{python}
gender_data.columns
```

These can also be called the *column labels*.


We have not paid attention so far to the numbers at the left of the table display, also in bold typeface.

In this case, they are ascending integers, starting at 0, with value 0 for the first row, 1 for the second row, and so on.

These numbers are the *index* of the data frame.  The index contains the *row labels*.

We can see the row labels / index with the `index` attribute of the data frame.

```{python}
gender_data.index
```

This is saying we have a simple index, that is like a `np.arange`, starting at 0, and continuing in steps of 1 up to 1, but not including 216.


Now let's look at the last 15 rows of the data frame.  We can get these with the `tail` method of the data frame.

```{python}
last_15 = gender_data.tail(15)
last_15
```

Here is the `index` of this new data frame.

```{python}
last_15.index
```

Notice that the first row no longer has the label 0 - it has label 201.

Notice too that the second row in this table is the USA, and it has the label 202.


Now imagine that I sort the data frame by GDP, and select the top 15 rows (and therefore, the top 15 richest countries):

```{python}
# Sort by GDP.
df_by_gdp = gender_data.sort_values('gdp_us_billion', ascending=False)
# Take the top 15 rows.
richest_15 = df_by_gdp.head(15)
richest_15
```

Now notice that the index values have followed the rows.  The row for the USA is now first, but it has kept its original index value (row label) 202.  The index value identifies the row.

Here's the index for this small table:

```{python}
richest_15.index
```

Now let us say that I wanted to get the eleventh row of this table.

I would be tempted to do something like `richest_15[10]` - but then - what will Pandas give me?   Does `10` mean the row label for "Australia"?  Or does it mean the eleventh row of the table, as it would for an array?  That is, will the indexing using the *labels* (index values)?  Or will it use the positions (as for indexing in Numpy arrays)?

The answer is, it is ambiguous, and when things are ambiguous, Pandas has to guess.   That's a bad idea, because then we have to guess what Pandas has guessed, and it's starting to get really confusing.

For that reason, we careful Pandas users never use indexing like `richest_15[10]` - we always use one of the two indexing attributes that Pandas provides.  Each does a different type of indexing.

* The `loc` (label locate) attribute indexes using the *labels* (row index).
* The `iloc` (position locate) attribute indexes using the positions.

Here they are in action:

```{python}
# Get the row with label 10
richest_15.loc[10]
```

```{python}
# Get the row at position / offset 10
richest_15.iloc[10]
```

Specifically what is happening is that `richest_15.loc` gives us a special thing that

* Know about the `richest_15` data frame
* Will give us rows and columns, if we use `[ something ]` on it.

So read `richest_15.loc[10]` as:

* Get the `richest_15` value (the data frame);
* Get the `loc` attribute of this data frame to return a special value that will give us rows and columns from the data frame,  by looking at labels;
* Use this value to fetch the row labeled 10.


Likewise `richest_15.iloc[10]` as:

* Get the `richest_15` value (the data frame);
* Get the `iloc` attribute of this data frame to return a special value that will give us rows and columns from the data frame, by looking at positions (offsets);
* Use this value to fetch the row at offset position 10.


When you select rows and columns from a data frame, consider carefully what you want.

Do you want to select rows and columns by *label* (by *index*, in the rows).  Then you want `.loc`.

Do you want to select rows and columns by *position* (offset).  Then you want `.iloc`.

## Loc and iloc indexing work on columns too


Consider this.  We use `.loc` and the label for the *row*, followed by the label for the *column*.

```{python}
richest_15.loc[10, 'gdp_us_billion']
```

Conversely, `iloc` only understands positions, and so, integers.  It does not understand or use labels:

```{python tags=c("raises-exception")}
# We can't specify columns by label, using iloc.
richest_15.iloc[10, 'gdp_us_billion']
```

`iloc` can get columns by their position.  For example, `fertility_rate` is the third column, and so we can get the fertility rate by asking `iloc` for the eleventh row, third column, like so:

```{python}
richest_15.iloc[10, 2]
```

## Series have an index too


Data frames have columns (and column labels), and rows (with row labels --- the index).

Series also have element labels --- they also have an index.

Consider this column, of the fertility rates of the richest countries:

```{python}
# Get the fert_rate column from the data frame
rich_ferts = richest_15['fert_rate']
rich_ferts.head()
```

As y'all know, this is a Series:

```{python}
type(rich_ferts)
```

You probably also spotted the numbers to the left of the values.  Yes, the row labels have come across from the data frame into the Series.  We can see that the first element has row label 202, and we remember that this is the row label (index value) for the USA.


As for the data frames, here is the index for the series:

```{python}
rich_ferts.index
```

Like data frames, we can index by label, with `loc`, and by position, with `iloc`:

```{python}
# The value for row labeled 10 - Australia.
rich_ferts.loc[10]
```

```{python}
# The value for the row at position 10 - Canada
rich_ferts.iloc[10]
```

## Rows from data frames are Series


Here we select the row at position 0 (the first row):

```{python}
first_row = richest_15.iloc[0]
first_row
```

This is a Series:

```{python}
type(first_row)
```

Notice that the Series has 9 elements, one for each column in the data frame.

We can see the number of rows and columns in a data frame with:

```{python}
richest_15.shape
```

Remember, the columns have names, which are also labels for the column.

When we select a row out of a data frame, we have one element per column, and the labels for the columns now become the labels for the rows.

```{python}
first_row.index
```

As for any other Series, we can get elements by label, with `loc`:

```{python}
first_row.loc['fert_rate']
```

We can also get elements by position (offset), with `iloc`:

```{python}
first_row.iloc[0]
```

## You can index without loc and iloc, but please don't unless


In the data frame introduction, you saw that we can index into data frame directly, using `[ something ]` after the data frame value, without using `loc` or `iloc`.  This is a very reasonable thing to do if:

* the `something` is a Boolean sequence.  This is not ambiguous.
* the `something` is a column name.  This isn't ambigous either.

For example, both of these are entirely reasonable uses of this kind of indexing.

```{python}
# Select rows where 'health_exp_per_cap' is greater than 3000 dollars.
big_health_spenders = richest_15[richest_15['health_exp_per_cap'] > 3000]
big_health_spenders
```

```{python}
# Select the 'country_code' column.
country_code = richest_15['country_code']
country_code
```

In fact Pandas will also allow you to this, with the Series we just made:

```{python}
# Nooooooo !
country_code[10]
```

Please don't do that.  This is ambiguous.  Did you really mean the country with label 10?  Or did you mean the country at position 10?   Pandas will guess for you.  Don't let it.  Always do this:

```{python}
# By label
country_code.loc[10]
```

or this:

```{python}
# By position
country_code.iloc[10]
```

        
      </section>

      <footer class="page__meta">
        
        


        
      </footer>

      

      

    </div>

    
  </article>

  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><input type="text" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
    <div id="results" class="results"></div></div>
      </div>
    

    

    
  <script src="/dsfe2019/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/releases/v5.0.12/js/all.js"></script>




<script src="/dsfe2019/assets/js/lunr/lunr.min.js"></script>
<script src="/dsfe2019/assets/js/lunr/lunr-store.js"></script>
<script src="/dsfe2019/assets/js/lunr/lunr-en.js"></script>




    <!-- Custom scripts to load after site JS is loaded -->

    <!-- Custom HTML used for the textbooks -->
<!-- Configure, then load MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      processEnvironments: true
    }
  };
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML-full,Safe" type="text/javascript"></script>


<script type="text/javascript">
// --- To auto-embed hub URLs in interact links if given in a RESTful fashion ---
function getJsonFromUrl(url) {
  var query = url.split('?');
  if (query.length < 2) {
    // No queries so just return false
    return false;
  }
  query = query[1];
  // Collect REST params into a dictionary
  var result = {};
  query.split("&").forEach(function(part) {
    var item = part.split("=");
    result[item[0]] = decodeURIComponent(item[1]);
  });
  return result;
}

// Parse a Binder URL, converting it to the string needed for JupyterHub
function binder2Jupyterhub(url) {
  newUrl = {};
  parts = url.split('v2/gh/')[1];
  // Grab the base repo information
  repoinfo = parts.split('?')[0];
  var [org, repo, ref] = repoinfo.split('/');
  newUrl['repo'] = ['https://github.com', org, repo].join('/');
  newUrl['branch'] = ref
  // Grab extra parameters passed
  params = getJsonFromUrl(url);
  if (params['filepath'] !== undefined) {
    newUrl['subPath'] = params['filepath']
  }
  return jQuery.param(newUrl);
}

// Filter out potentially unsafe characters to prevent xss
function safeUrl(url)
{
   return String(encodeURIComponent(url))
            .replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
}

function addParamToInternalLinks(hub) {
  var links = $("a").each(function() {
    var href = this.href;
    // If the link is an internal link...
    if (href.search("https://matthew-brett.github.io") !== -1 || href.startsWith('/') || href.search("127.0.0.1:") !== -1) {
      // Assume we're an internal link, add the hub param to it
      var params = getJsonFromUrl(href);
      if (params !== false) {
        // We have REST params, so append a new one
        params['hub'] = hub;
      } else {
        // Create the REST params
        params = {'hub': hub};
      }
      // Update the link
      var newHref = href.split('?')[0] + '?' + jQuery.param(params);
      this.setAttribute('href', decodeURIComponent(newHref));
    }
  });
  return false;
}

  // Update interact links
function updateInteractLink() {
    // hack to make this work since it expects a ? in the URL
    rest = getJsonFromUrl("?" + location.search.substr(1));
    hubUrl = rest['hub'];
    if (hubUrl !== undefined) {
      // Sanitize the hubUrl
      hubUrl = safeUrl(hubUrl);
      // Add HTTP text if omitted
      if (hubUrl.indexOf('http') < 0) {hubUrl = 'http://' + hubUrl;}
      link = $("a.interact-button")[0];
      if (link !== undefined) {
          // Update the interact link URL
          var href = link.getAttribute('href');
          if ('binder' == 'binder') {
            // If binder links exist, we need to re-work them for jupyterhub
            first = [hubUrl, 'hub', 'user-redirect', 'git-sync'].join('/')
            href = first + '?' + binder2Jupyterhub(href);
          } else {
            // If JupyterHub links, we only need to replace the hub url
            href = href.replace("https://mybinder.org", hubUrl);
          }
          link.setAttribute('href', decodeURIComponent(href));

          // Add text after interact link saying where we're launching
          hubUrlNoHttp = decodeURIComponent(hubUrl).replace('http://', '').replace('https://', '');
          $("a.interact-button").after($('<div class="interact-context">on ' + hubUrlNoHttp + '</div>'));

      }
      // Update internal links so we retain the hub url
      addParamToInternalLinks(hubUrl);
    }
}

// --- Highlight the part of sidebar for current page ---

// helper to replace trailing slash
function replaceSlash(string)
{
    return string.replace(/\/$/, "");
}

// Add a class to the current page in the sidebar
function highlightSidebarCurrentPage()
{
  var currentpage = location.href;
  var links = $('.sidebar .nav__items a');
  var ii = 0;
  for(ii; ii < links.length; ii++) {
    var link = links[ii];
    if(replaceSlash(link.href) == replaceSlash(currentpage)) {
      // Add CSS for styling
      link.classList.add("current");
      // Scroll to this element
      $('div.sidebar').scrollTop(link.offsetTop - 300);
    }
  }
}

// --- Set up copy/paste for code blocks ---
function addCopyButtonToCode(){
  // get all <code> elements
  var allCodeBlocksElements = $( "div.input_area code, div.highlighter-rouge code" );

  allCodeBlocksElements.each(function(ii) {
   	// add different id for each code block

  	// target
    var currentId = "codeblock" + (ii + 1);
    $(this).attr('id', currentId);

    //trigger
    var clipButton = '<button class="btn copybtn" data-clipboard-target="#' + currentId + '"><img src="https://clipboardjs.com/assets/images/clippy.svg" width="13" alt="Copy to clipboard"></button>';
       $(this).after(clipButton);
    });

    new Clipboard('.btn');
}

// Run scripts when page is loaded
$(document).ready(function () {
  // Add anchors to H1 etc links
  anchors.add();
  // Highlight current page in sidebar
  highlightSidebarCurrentPage();
  // Add copy button to code blocks
  addCopyButtonToCode();
  // Update the Interact link if a REST param given
  updateInteractLink();
});
</script>

  </body>
</html>
